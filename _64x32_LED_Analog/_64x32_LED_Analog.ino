// 64x32 Uno LED panel Analog
// Fast Clock Mod
// 3/7/2019 by Bob Davis

// #define A   A0  // Port D assignments
// #define B   A1
// #define C   A2
// #define D   A3
// #define E   A4
// #define CLK 8 // Port B assignments   
// #define OE  9
// #define LAT 10
//#define PIN_4 4 //analog input
//#define PIN_5 5 //analog input

int C12[16] = {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
int C13[16] = {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0};

#define MaxLed 64
byte BGC1=0x00;  // Background
byte FGC1=0x1C;  // Foreground
byte BGC2=0x00;  // Background
byte FGC2=0xE0;  // Foreground

#define PIXEL_PORT PORTD  // Port the pixels are connected to
#define PIXEL_DDR  DDRD   // D2-D7
#define ROW_PORT   PORTC  // Port the rows are connected to
#define ROW_DDR    DDRC   // A0-A5
#define CLK_PORT   PORTB  // Port the Clock/LE/OE are connected to
#define CLK_DDR    DDRB   // D8-D10

char text1[10]=" ";
char text2[10]=" ";

// This font from http://sunge.awardspace.com/glcd-sd/node4.html
byte font[][7] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ascii 32 
0x00,0x00,0xfa,0x00,0x00,0x00,0x00, // !
0x00,0xe0,0x00,0xe0,0x00,0x00,0x00, // "
0x28,0xfe,0x28,0xfe,0x28,0x00,0x00, // #
0x00,0x34,0xfe,0x58,0x00,0x00,0x00, // $
0xc4,0xc8,0x10,0x26,0x46,0x00,0x00, // %
0x6c,0x92,0xaa,0x44,0x0a,0x00,0x00, // &
0x00,0xa0,0xc0,0x00,0x00,0x00,0x00, // '
0x00,0x38,0x44,0x82,0x00,0x00,0x00, // (
0x00,0x82,0x44,0x38,0x00,0x00,0x00, // )
0x10,0x54,0x38,0x54,0x10,0x00,0x00, // *
0x10,0x10,0x7c,0x10,0x10,0x00,0x00, // +
0x00,0x0a,0x0c,0x00,0x00,0x00,0x00, // ,
0x10,0x10,0x10,0x10,0x10,0x00,0x00, // -
0x00,0x06,0x06,0x00,0x00,0x00,0x00, // .
0x04,0x08,0x10,0x20,0x40,0x00,0x00, // /
0x7c,0x8a,0x92,0xa2,0x7c,0x00,0x00, // 0
0x00,0x42,0xfe,0x02,0x00,0x00,0x00, // 1
0x42,0x86,0x8a,0x92,0x62,0x00,0x00, // 2
0x84,0x82,0xa2,0xd2,0x8c,0x00,0x00, // 3
0x18,0x28,0x48,0xfe,0x08,0x00,0x00, // 4
0xe4,0xa2,0xa2,0xa2,0x9c,0x00,0x00, // 5
0x3c,0x52,0x92,0x92,0x0c,0x00,0x00, // 6
0x80,0x8e,0x90,0xa0,0xc0,0x00,0x00, // 7
0x6c,0x92,0x92,0x92,0x6c,0x00,0x00, // 8
0x60,0x92,0x92,0x94,0x78,0x00,0x00, // 9
0x00,0x6c,0x6c,0x00,0x00,0x00,0x00, // :
0x00,0x6a,0x6c,0x00,0x00,0x00,0x00, // ;
0x00,0x10,0x28,0x44,0x82,0x00,0x00, // <
0x28,0x28,0x28,0x28,0x28,0x00,0x00, // =
0x82,0x44,0x28,0x10,0x00,0x00,0x00, // >
0x40,0x80,0x8a,0x90,0x60,0x00,0x00, // ?
0x4c,0x92,0x9e,0x82,0x7c,0x00,0x00, // @
0x7e,0x90,0x90,0x90,0x7e,0x00,0x00, // A
0xfe,0x92,0x92,0x92,0x6c,0x00,0x00, // B
0x7c,0x82,0x82,0x82,0x44,0x00,0x00, // C
0xfe,0x82,0x82,0x82,0x7c,0x00,0x00, // D
0xfe,0x92,0x92,0x92,0x82,0x00,0x00, // E
0xfe,0x90,0x90,0x80,0x80,0x00,0x00, // F
0x7c,0x82,0x82,0x8a,0x4c,0x00,0x00, // G
0xfe,0x10,0x10,0x10,0xfe,0x00,0x00, // H
0x00,0x82,0xfe,0x82,0x00,0x00,0x00, // I
0x04,0x02,0x82,0xfc,0x80,0x00,0x00, // J
0xfe,0x10,0x28,0x44,0x82,0x00,0x00, // K
0xfe,0x02,0x02,0x02,0x02,0x00,0x00, // L
0xfe,0x40,0x20,0x40,0xfe,0x00,0x00, // M
0xfe,0x20,0x10,0x08,0xfe,0x00,0x00, // N
0x7c,0x82,0x82,0x82,0x7c,0x00,0x00, // O
0xfe,0x90,0x90,0x90,0x60,0x00,0x00, // P
0x7c,0x82,0x8a,0x84,0x7a,0x00,0x00, // Q
0xfe,0x90,0x98,0x94,0x62,0x00,0x00, // R
0x62,0x92,0x92,0x92,0x8c,0x00,0x00, // S
0x80,0x80,0xfe,0x80,0x80,0x00,0x00, // T
0xfc,0x02,0x02,0x02,0xfc,0x00,0x00, // U
0xf8,0x04,0x02,0x04,0xf8,0x00,0x00, // V
0xfe,0x04,0x18,0x04,0xfe,0x00,0x00, // W
0xc6,0x28,0x10,0x28,0xc6,0x00,0x00, // X
0xc0,0x20,0x1e,0x20,0xc0,0x00,0x00, // Y
0x86,0x8a,0x92,0xa2,0xc2,0x00,0x00,  // Z
};

void setup() {
  PIXEL_DDR = 0xFC;  // Set all pixel pins to output
  ROW_DDR = 0x0F;    // Set all row pins to output
  CLK_DDR = 0x0F;    // Set all CLK/LE/OE pins to output

  PORTB=0;
  // Send Data to control register 11
  for (int l=0; l<MaxLed; l++){
    int y=l%16;
    PORTD = 0x00;
    if (C12[y]==1) PORTD=0xFC;
      if (l>MaxLed-12){ PORTB=7; PORTB=6; }
      else{ PORTB=1; PORTB=0; }
    }
  PORTB=0;
  // Send Data to control register 12 
  for (int l=0; l<MaxLed; l++){
    int y=l%16;
    PORTD = 0x00;
    if (C13[y]==1) PORTD=0xFC;
      if (l>MaxLed-13){ PORTB=7; PORTB=6; }
      else{ PORTB=1; PORTB=0; }
    }
  PORTB=0;
}

void loop() {
  for (int c=0; c<600; c++){
    int  va4 = analogRead(A4)/2; // Get the value
    int  va5 = analogRead(A5)/2; // Get the value
    sprintf(text1, "A4 = %03d", va4);
    sprintf(text2, "A5 = %03d", va5);
    // Select the Row
    for (int r=0; r<16; r++){
      for (int l=0; l<MaxLed; l++){
        int y=l%8; // remainder after division
        int pd1 = BGC1;
        int pd2 = BGC2;
        if (y < 6){
          if (r<8){
            if ((font[text1[l/8]-32][y] >> 8-r) & 0x01==1) pd1=FGC1; 
            if ((font[text2[l/8]-32][y] >> 8-r) & 0x01==1) pd2=FGC2;
          }
          if (r==11 or r==12) { 
            if (l<va4/8) {pd1=0x08;
              if (l >48) pd1=0x04;
            }
            if (l<va5/8) {pd2=0x40; 
              if (l >48) pd2=0x20;
            }
          }
          PORTD=pd1+pd2;
        }
        if (l>MaxLed-3){ PORTB=7; PORTB=6; }
        else{ PORTB=1; PORTB=0; }
      }
      PORTC=r;  // Update row
      PORTB=0;
    }
  }
}
